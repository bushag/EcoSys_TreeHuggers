---
title: "NEON_group_project"
author: "TG"
date: "2025-04-27"
output:
  html_document: 
    toc: true
    toc_float: true
    toc_depth: 4
  pdf_document: 
    toc: true
    number_sections: true
    toc_depth: 4
  word_document: 
    number_sections: true
---

# Notes before reading 
## *Note - I commented-out the chunks for downloads and writing CSVs. If you want to un-comment these out, you can search "#COMMENTED OUT", which is typed above each commented-out chunk.*

## ***Check out my knit html file for way easier viewing. You'll be able to skip to the heading with today's date in it!***

### Other notes: 
#DELA and LENO - used bulkDensThirdBar as basis for site and plot means used in gap filling due to lack of bulkDensFieldMoist data.
#ggbreak doesn't like me, sorry for lack of visualization in Nitrogen proccessing 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#ggbreak package does not work for my version of R, for some reason. I apologize that visualization for Nitrogen isn't possible for the below code, but it should be working otherwise. 

Environment
```{r}											
rm(list = ls())
library(neonUtilities)								
library(tidyverse)
library(lubridate)
library(dplyr)
library(ggplot2)
library(patchwork)
library(neonNTrans) 
library(nlme)
```

#COMMENTED OUT 
```{r}
#library(ggbreak)
# install.packages("ggimage")
# #Necessary packages / commands for installling neonNTrans. Follow directions to update packages as needed. You can try to call for compilation for packages, but use binary if needed.
# #library(devtools) 
# #install_github("NEONScience/NEON-Nitrogen-Transformations/neonNTrans", #dependencies=TRUE)
```


# Carbon!!

## Trees

### DELA -- Tree Carbon Stocks
Downloading the data of interest from NEON

#COMMENTED OUT
```{r}												
# DELA.trees <- loadByProduct(dpID="DP1.10098.001",
# site=c("DELA"),
# startdate="2012-01", enddate="2024-12",
# package="basic")
# 
# list2env(DELA.trees, .GlobalEnv)
```

Write CSVs for four tables extracted
#COMMENTED OUT
```{r}
# #readme_10098
# write.csv(readme_10098, "readme_10098_DELA.csv")
# 
# #vst_perplotperyear
# write.csv(vst_perplotperyear, "vst_perplotperyear_DELA.csv")
# 
# #vst_apparentindividual
# write.csv(vst_apparentindividual, "vst_apparentindividual_DELA.csv")
# 
# #variables_10098
# write.csv(variables_10098, "variables_10098_DELA.csv")
```

readme_10098 has a description of all the dataframes and variables_10098 defines all the variables in each dataframe. As you are working with NEON data in the future, you’ll want to familiarize yourself with these, but for the rest of this activity we will not need to refer to them.

Read in one of the CSVs we wrote above and revise to be compatible with the one that holds tree measurements
```{r}											
vst_perplotperyear_DELA <- read.csv("vst_perplotperyear_DELA.csv")
variables_10098_DELA <- read.csv("variables_10098_DELA.csv")

#making a new dataframe with selected variables
plot.info.vst.DELA <- vst_perplotperyear_DELA %>%
select(date, domainID, siteID, plotID, plotType, nlcdClass, totalSampledAreaTrees)

#making a new variable that containers only year
plot.info.vst.DELA <- plot.info.vst.DELA %>%
mutate(year= year(date))

#making new dataframe where you filter only the most recent sampling year for each PLOT
plot.info.vst.DELA.rec <- plot.info.vst.DELA %>%
group_by(plotID)%>%
filter(year==max(year))

#remove NAs from the totalSampledAreaTrees variable 
plot.info.vst.DELA.rec <- plot.info.vst.DELA.rec %>% filter(totalSampledAreaTrees!="NA")

```

Repeating the process above for individual dataframe
```{r}											
vst_apparentindividual_DELA <- read.csv("vst_apparentindividual_DELA.csv")

#making a new dataframe with selected variables
individuals.vst.DELA <- vst_apparentindividual_DELA %>%
select(date, siteID, plotID, individualID, growthForm, stemDiameter, plantStatus)

#making a new variable that containers only year
individuals.vst.DELA <- individuals.vst.DELA %>%
mutate(year= year(date))

#making new dataframe where you filter only the most recent sampling year for each INDIVIDUAL
most.recent.individuals.vst.DELA <- individuals.vst.DELA %>%
group_by(individualID) %>%
filter(year==max(year))

#making new dataframe where you filter the prior dataframe for only live trees
most.recent.live.plants.DELA.vst <- most.recent.individuals.vst.DELA %>% filter(str_detect(plantStatus, "Live"))
#little unsure
str(most.recent.individuals.vst.DELA)

#making new dataframe for single bole trees, multi-bole trees, and small trees only
most.recent.live.trees1.DELA <- most.recent.live.plants.DELA.vst %>%
  filter(growthForm=="single bole tree" | growthForm=="multi-bole tree" | growthForm=="small tree")
str(most.recent.live.trees1.DELA)

#for dataframe above now we are excluding trees that have a recorded stem diameter of NA, we need to do this for analysis
most.recent.live.trees.DELA <- subset(most.recent.live.trees1.DELA, stemDiameter>0)

```

Joining dataframes for DELA
```{r}

tree.data.DELA <- left_join(most.recent.live.trees.DELA, plot.info.vst.DELA.rec)

tree.data.DELA.complete<-subset(tree.data.DELA, totalSampledAreaTrees>0)

```

```{r}

#need a new column in joined dataframe that represents biomass of each tree (in kg) called AGB
#mixed hardwood allometric equation from jenkins et al 2003
#Equation that I need to use is ABG (kg) = exp(B0 + B1 x ln(dbh))
tree.data.DELA.complete$AGB <- exp(-2.4800 + (2.4835*log(tree.data.DELA.complete$stemDiameter))) #this equation gives kg

#now need to create a new dataframe called AGB.trees.by.plot.DELA
AGB.trees.by.plot.DELA <- tree.data.DELA.complete %>%
  group_by(siteID, plotID, totalSampledAreaTrees) %>% #grouping variables together
  summarise(plot.AGB = sum(AGB)) #summing by grouping variables 
# View(AGB.trees.by.plot.DELA)

AGB.trees.by.plot.DELA$AGB.kg.m2<-AGB.trees.by.plot.DELA$plot.AGB/AGB.trees.by.plot.DELA$totalSampledAreaTrees #making it as kg/m2

#Okay, need to get m2 to ha (10,000 m2 = 1 ha)
#then to get kg to mg (1,000 kg = 1 mg)

AGB.trees.by.plot.DELA <- AGB.trees.by.plot.DELA %>%
  mutate(AGB.kg.m2 = plot.AGB/totalSampledAreaTrees) %>%
  mutate(AGB.Mg.ha = (((AGB.kg.m2)*10))) %>%
  mutate(AGB.C.Mg.ha = AGB.Mg.ha*0.47)
# View(AGB.trees.by.plot.DELA)


```

```{r}
ggplot(data=AGB.trees.by.plot.DELA, aes(x=plotID, y=AGB.C.Mg.ha)) + 
geom_jitter()+
theme_classic()+
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

```


### LENO -- Tree Carbon Stocks
Downloading the data of interest from NEON
#COMMENTED OUT
```{r}												
# LENO.trees <- loadByProduct(dpID="DP1.10098.001", 	
# site=c("LENO"), 		
# startdate="2012-01", enddate="2024-12", 				
# package="basic")
# 
# list2env(LENO.trees, .GlobalEnv)
```	

Write CSVs for four tables extracted
#COMMENTED OUT
```{r}											
# #readme_10098
# write.csv(readme_10098, "readme_10098_LENO.csv")
# 
# #vst_perplotperyear
# write.csv(vst_perplotperyear, "vst_perplotperyear_LENO.csv")
# 
# #vst_apparentindividual
# write.csv(vst_apparentindividual, "vst_apparentindividual_LENO.csv")
# 
# #variables_10098
# write.csv(variables_10098, "variables_10098_LENO.csv")
```

readme_10098 has a description of all the dataframes and variables_10098 defines all the variables in each dataframe. As you are working with NEON data in the future, you’ll want to familiarize yourself with these, but for the rest of this activity we will not need to refer to them.

Read in one of the CSVs we wrote above and revise to be compatible with the one that holds tree measurements
```{r}											
vst_perplotperyear_LENO <- read.csv("vst_perplotperyear_LENO.csv")
variables_10098_LENO <- read.csv("variables_10098_LENO.csv")

#making a new dataframe with selected variables
plot.info.vst.LENO <- vst_perplotperyear_LENO %>%
select(date, domainID, siteID, plotID, plotType, nlcdClass, totalSampledAreaTrees)

#making a new variable that containers only year
plot.info.vst.LENO <- plot.info.vst.LENO %>%
mutate(year= year(date))

#making new dataframe where you filter only the most recent sampling year for each PLOT
plot.info.vst.LENO.rec <- plot.info.vst.LENO %>%
group_by(plotID)%>%
filter(year==max(year))

#remove NAs from the totalSampledAreaTrees variable 
plot.info.vst.LENO.rec <- plot.info.vst.LENO.rec %>% filter(totalSampledAreaTrees!="NA")

```

Repeating the process above for individual dataframe
```{r}											
vst_apparentindividual_LENO <- read.csv("vst_apparentindividual_LENO.csv")

#making a new dataframe with selected variables
individuals.vst.LENO <- vst_apparentindividual_LENO %>%
select(date, siteID, plotID, individualID, growthForm, stemDiameter, plantStatus)

#making a new variable that containers only year
individuals.vst.LENO <- individuals.vst.LENO %>%
mutate(year= year(date))

#making new dataframe where you filter only the most recent sampling year for each INDIVIDUAL
most.recent.individuals.vst.LENO <- individuals.vst.LENO %>%
group_by(individualID) %>%
filter(year==max(year))

#making new dataframe where you filter the prior dataframe for only live trees
most.recent.live.plants.LENO.vst <- most.recent.individuals.vst.LENO %>%
filter(str_detect(plantStatus, "Live")) #little unsure here

#making new dataframe for single bole trees, multi-bole trees, and small trees only
most.recent.live.trees1.LENO <- most.recent.live.plants.LENO.vst %>%
  filter(growthForm=="single bole tree" | growthForm=="multi-bole tree" | growthForm=="small tree")

#for dataframe above now we are excluding trees that have a recorded stem diameter of NA, we need to do this for analysis
most.recent.live.trees.LENO <- subset(most.recent.live.trees1.LENO, stemDiameter>0)

```

Joining dataframes for LENO
```{r}


tree.data.LENO <- left_join(most.recent.live.trees.LENO, plot.info.vst.LENO.rec)


tree.data.LENO.complete<-subset(tree.data.LENO, totalSampledAreaTrees>0)

```

```{r}

#need a new column in joined dataframe that represents biomass of each tree (in kg) called AGB
#mixed hardwood allometric equation from jenkins et al 2003
#Equation that I need to use is ABG (kg) = exp(B0 + B1 x ln(dbh))
tree.data.LENO.complete$AGB <- exp(-2.4800 + (2.4835*log(tree.data.LENO.complete$stemDiameter))) #this equation gives kg

#now need to create a new dataframe called AGB.trees.by.plot.LENO
AGB.trees.by.plot.LENO <- tree.data.LENO.complete %>%
  group_by(siteID, plotID, totalSampledAreaTrees) %>% #grouping variables together
  summarise(plot.AGB = sum(AGB)) #summing by grouping variables 
#View(AGB.trees.by.plot.LENO)

AGB.trees.by.plot.LENO$AGB.kg.m2<-AGB.trees.by.plot.LENO$plot.AGB/AGB.trees.by.plot.LENO$totalSampledAreaTrees #making it as kg/m2

#Okay, need to get m2 to ha (10,000 m2 = 1 ha)
#then to get kg to mg (1,000 kg = 1 mg)

AGB.trees.by.plot.LENO <- AGB.trees.by.plot.LENO %>%
  mutate(AGB.kg.m2 = plot.AGB/totalSampledAreaTrees) %>%
  mutate(AGB.Mg.ha = (((AGB.kg.m2)*10))) %>%
  mutate(AGB.C.Mg.ha = AGB.Mg.ha*0.47)
# View(AGB.trees.by.plot.LENO)

```

```{r}
ggplot(data=AGB.trees.by.plot.LENO, aes(x=plotID, y=AGB.C.Mg.ha)) + 
geom_jitter()+
theme_classic()+
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

```

### TALL -- Tree Carbon Stocks
Downloading the data of interest from NEON
#COMMENTED OUT
```{r}												
# TALL.trees <- loadByProduct(dpID="DP1.10098.001", 	
# site=c("TALL"), 		
# startdate="2012-01", enddate="2024-12", 				
# package="basic")
# 
# list2env(TALL.trees, .GlobalEnv)
```	

Write CSVs for four tables extracted
#COMMENTED OUT
```{r}											
# #readme_10098
# write.csv(readme_10098, "readme_10098_TALL.csv")
# 
# #vst_perplotperyear
# write.csv(vst_perplotperyear, "vst_perplotperyear_TALL.csv")
# 
# #vst_apparentindividual
#  write.csv(vst_apparentindividual, "vst_apparentindividual_TALL.csv")
# 
# #variables_10098
# write.csv(variables_10098, "variables_10098_TALL.csv")
```

readme_10098 has a description of all the dataframes and variables_10098 defines all the variables in each dataframe. As you are working with NEON data in the future, you’ll want to familiarize yourself with these, but for the rest of this activity we will not need to refer to them.

Read in one of the CSVs we wrote above and revise to be compatible with the one that holds tree measurements
```{r}											
vst_perplotperyear_TALL <- read.csv("vst_perplotperyear_TALL.csv")
variables_10098_TALL <- read.csv("variables_10098_TALL.csv")

#making a new dataframe with selected variables
plot.info.vst.TALL <- vst_perplotperyear_TALL %>%
select(date, domainID, siteID, plotID, plotType, nlcdClass, totalSampledAreaTrees)

#making a new variable that containers only year
plot.info.vst.TALL <- plot.info.vst.TALL %>%
mutate(year= year(date))

#making new dataframe where you filter only the most recent sampling year for each PLOT
plot.info.vst.TALL.rec <- plot.info.vst.TALL %>%
group_by(plotID)%>%
filter(year==max(year))

#remove NAs from the totalSampledAreaTrees variable 
plot.info.vst.TALL.rec <- plot.info.vst.TALL.rec %>% filter(totalSampledAreaTrees!="NA")

```

Repeating the process above for individual dataframe
```{r}											
vst_apparentindividual_TALL <- read.csv("vst_apparentindividual_TALL.csv")

#making a new dataframe with selected variables
individuals.vst.TALL <- vst_apparentindividual_TALL %>%
select(date, siteID, plotID, individualID, growthForm, stemDiameter, plantStatus)

#making a new variable that containers only year
individuals.vst.TALL <- individuals.vst.TALL %>%
mutate(year= year(date))

#making new dataframe where you filter only the most recent sampling year for each INDIVIDUAL
most.recent.individuals.vst.TALL <- individuals.vst.TALL %>%
group_by(individualID) %>%
filter(year==max(year))

#making new dataframe where you filter the prior dataframe for only live trees
most.recent.live.plants.TALL.vst <- most.recent.individuals.vst.TALL %>%
filter(str_detect(plantStatus, "Live")) #little unsure here

#making new dataframe for single bole trees, multi-bole trees, and small trees only
most.recent.live.trees1.TALL <- most.recent.live.plants.TALL.vst %>%
  filter(growthForm=="single bole tree" | growthForm=="multi-bole tree" | growthForm=="small tree")

#for dataframe above now we are excluding trees that have a recorded stem diameter of NA, we need to do this for analysis
most.recent.live.trees.TALL <- subset(most.recent.live.trees1.TALL, stemDiameter>0)

```

Joining dataframes for TALL
```{r}

tree.data.TALL <- left_join(most.recent.live.trees.TALL, plot.info.vst.TALL.rec)

tree.data.TALL.complete<-subset(tree.data.TALL, totalSampledAreaTrees>0)

```

```{r}

#need a new column in joined dataframe that represents biomass of each tree (in kg) called AGB
#mixed hardwood allometric equation from jenkins et al 2003
#Equation that I need to use is ABG (kg) = exp(B0 + B1 x ln(dbh))
tree.data.TALL.complete$AGB <- exp(-2.4800 + (2.4835*log(tree.data.TALL.complete$stemDiameter))) #this equation gives kg

#now need to create a new dataframe called AGB.trees.by.plot.TALL
AGB.trees.by.plot.TALL <- tree.data.TALL.complete %>%
  group_by(siteID, plotID, totalSampledAreaTrees) %>% #grouping variables together
  summarise(plot.AGB = sum(AGB)) #summing by grouping variables 
# View(AGB.trees.by.plot.TALL)

AGB.trees.by.plot.TALL$AGB.kg.m2<-AGB.trees.by.plot.TALL$plot.AGB/AGB.trees.by.plot.TALL$totalSampledAreaTrees #making it as kg/m2

#Okay, need to get m2 to ha (10,000 m2 = 1 ha)
#then to get kg to mg (1,000 kg = 1 mg)

AGB.trees.by.plot.TALL <- AGB.trees.by.plot.TALL %>%
  mutate(AGB.kg.m2 = plot.AGB/totalSampledAreaTrees) %>%
  mutate(AGB.Mg.ha = (((AGB.kg.m2)*10))) %>%
  mutate(AGB.C.Mg.ha = AGB.Mg.ha*0.47)
# View(AGB.trees.by.plot.TALL)

```

```{r}
ggplot(data=AGB.trees.by.plot.TALL, aes(x=plotID, y=AGB.C.Mg.ha)) + 
geom_jitter()+
theme_classic()+
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

```

### Joining dataframes across D08 (Ozark Complex) for Tree Carbon Stocks
```{r}

AGB.trees.by.plot.D08 <- full_join(AGB.trees.by.plot.DELA, AGB.trees.by.plot.LENO)
AGB.trees.by.plot.D08 <- full_join(AGB.trees.by.plot.D08, AGB.trees.by.plot.TALL)

```

### Visualizing Tree Carbon Stocks by site of D08
```{r}

AGB.trees.by.plot.D08.summarise <- AGB.trees.by.plot.D08 %>%
 group_by(siteID) %>%
 summarise(AGB.C.Mg.ha_siteAverage = mean(AGB.C.Mg.ha),
           AGB.C.Mg.ha_siteSD = sd(AGB.C.Mg.ha))
 
ggplot(data=AGB.trees.by.plot.D08, aes(x=siteID, y=AGB.C.Mg.ha, group = siteID, color=siteID)) + 
  geom_point(size=1.5, alpha = 0.3, position = position_jitterdodge(dodge.width = 0.5))  +
  geom_point(data = AGB.trees.by.plot.D08.summarise, aes(x = siteID, y = AGB.C.Mg.ha_siteAverage, group = siteID, color=siteID), size = 3.5, alpha = 0.8, position = position_dodge(width = 0.5)) +
  geom_errorbar(data = AGB.trees.by.plot.D08.summarise, aes(x= siteID, y = AGB.C.Mg.ha_siteAverage, ymin = (AGB.C.Mg.ha_siteAverage-AGB.C.Mg.ha_siteSD), ymax = (AGB.C.Mg.ha_siteAverage+AGB.C.Mg.ha_siteSD), colour = siteID), width = 0.2) +
        scale_color_brewer(name = "SiteID", palette = "Dark2") + #color-blind friendly
        ggtitle("Tree Carbon Stocks by Site of D08") +
        ylab("Carbon Stock (Mg/ha)") +
        theme_classic(base_size = 16) +
        theme(plot.title = element_text(size=16, hjust = 0.5),
              axis.text.x=element_text(size=12, color = "black"),
              axis.text.y=element_text(size=12),
              axis.title.y=element_text(size=14), 
              axis.title.x=element_blank(), 
              legend.text=element_text(size=14),
              legend.title=element_text(size=14),
              legend.position = "none") 

#Writing the joined dataframe into CSV file
write.csv(AGB.trees.by.plot.D08, "AGB.trees.by.plot.D08.csv")

```

## Roots

### DELA -- Root Carbon Stocks
Create a chunk where you extract root biomass using NEON utilies package, get into environment, and write csvs into the environment
#COMMENTED OUT
```{r}

# DELA.roots <- loadByProduct(dpID="DP1.10067.001", 	
# site=c("DELA"), 		
# startdate="2012-01", enddate="2024-12", 				
# package="basic")
# 
# list2env(DELA.roots, .GlobalEnv)
# 
# #readme_10067
# write.csv(readme_10067, "readme_10067_DELA.csv")
# 
# #bbc_percore
# write.csv(bbc_percore, "bbc_percore_DELA.csv")
# 
# #bbc_rootmass
# write.csv(bbc_rootmass, "bbc_rootmass_DELA.csv")
# 
# #variables_10067
# write.csv(variables_10067, "variables_10067_DELA.csv")

```

Create chunk selecting variables to create new dfs
```{r}

bbc_rootmass_DELA <- read.csv("bbc_rootmass_DELA.csv")
bbc_percore_DELA <- read.csv("bbc_percore_DELA.csv")

root.mass.DELA <- bbc_rootmass_DELA %>%
select(domainID, plotID, sampleID, subsampleID, collectDate, sizeCategory, rootStatus, dryMass)

root.core.DELA <- bbc_percore_DELA %>%
 select(domainID, plotID, subplotID, sampleID, clipID, coreID, collectDate, rootSampleArea, rootSampleDepth, coreDiameter)


root.data.DELA <- left_join(root.mass.DELA, root.core.DELA)

root.data.DELA$year <- substr(root.data.DELA$collectDate, start=1, stop=4) 

```

Root calculations and conversions
```{r}

roots.by.sample.DELA <- root.data.DELA %>% 
  group_by(plotID, sampleID, rootSampleArea, rootSampleDepth) %>%
  summarise(total.mass = sum(dryMass))

roots.by.sample.DELA.final <- roots.by.sample.DELA %>%
  mutate(root.gC.sample = (total.mass * 0.47)) %>%
  mutate(root.gC.m2 = (root.gC.sample/rootSampleArea)) %>%
  mutate(root.MgC.ha = (root.gC.m2 * 0.01))
 
roots.by.plot.DELA <- roots.by.sample.DELA.final %>% 
  group_by(plotID) %>%
  summarise(mean.root.MgC.ha = mean(root.MgC.ha))

```

Visualize the data
```{r}

ggplot(data=roots.by.plot.DELA, aes(x=plotID, y=mean.root.MgC.ha)) + 
geom_jitter()+
theme_classic()+
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

```

### LENO -- Root Carbon Stocks
Create a chunk where you extract root biomass using NEON utilies package, get into environment, and write csvs into the environment
#COMMENTED OUT
```{r}

# LENO.roots <- loadByProduct(dpID="DP1.10067.001",
# site=c("LENO"),
# startdate="2012-01", enddate="2024-12",
# package="basic")
# 
# list2env(LENO.roots, .GlobalEnv)
# 
# #readme_10067
# write.csv(readme_10067, "readme_10067_LENO.csv")
# 
# #bbc_percore
# write.csv(bbc_percore, "bbc_percore_LENO.csv")
# 
# #bbc_rootmass
# write.csv(bbc_rootmass, "bbc_rootmass_LENO.csv")
# 
# #variables_10067
# write.csv(variables_10067, "variables_10067_LENO.csv")

```

Create chunk selecting variables to create new dfs
```{r}

bbc_rootmass_LENO <- read.csv("bbc_rootmass_LENO.csv")
bbc_percore_LENO <- read.csv("bbc_percore_LENO.csv")

root.mass.LENO <- bbc_rootmass_LENO %>%
select(domainID, plotID, sampleID, subsampleID, collectDate, sizeCategory, rootStatus, dryMass)

root.core.LENO <- bbc_percore_LENO %>%
 select(domainID, plotID, subplotID, sampleID, clipID, coreID, collectDate, rootSampleArea, rootSampleDepth, coreDiameter)


root.data.LENO <- left_join(root.mass.LENO, root.core.LENO)

root.data.LENO$year <- substr(root.data.LENO$collectDate, start=1, stop=4) 

```

Root calculations and conversions
```{r}

roots.by.sample.LENO <- root.data.LENO %>% 
  group_by(plotID, sampleID, rootSampleArea, rootSampleDepth) %>%
  summarise(total.mass = sum(dryMass))

roots.by.sample.LENO.final <- roots.by.sample.LENO %>%
  mutate(root.gC.sample = (total.mass * 0.47)) %>%
  mutate(root.gC.m2 = (root.gC.sample/rootSampleArea)) %>%
  mutate(root.MgC.ha = (root.gC.m2 * 0.01))
 
roots.by.plot.LENO <- roots.by.sample.LENO.final %>% 
  group_by(plotID) %>%
  summarise(mean.root.MgC.ha = mean(root.MgC.ha))

```

Visualize the data
```{r}

ggplot(data=roots.by.plot.LENO, aes(x=plotID, y=mean.root.MgC.ha)) + 
geom_jitter()+
theme_classic()+
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

```

### TALL -- Root Carbon Stocks
Create a chunk where you extract root biomass using NEON utilies package, get into environment, and write csvs into the environment
#COMMENTED OUT
```{r}

# TALL.roots <- loadByProduct(dpID="DP1.10067.001", 	
# site=c("TALL"), 		
# startdate="2012-01", enddate="2024-12", 				
# package="basic")
# 
#  list2env(TALL.roots, .GlobalEnv)
# 
# #readme_10067
# write.csv(readme_10067, "readme_10067_TALL.csv")
# 
# #bbc_percore
# write.csv(bbc_percore, "bbc_percore_TALL.csv")
# 
# #bbc_rootmass
# write.csv(bbc_rootmass, "bbc_rootmass_TALL.csv")
# 
# #variables_10067
# write.csv(variables_10067, "variables_10067_TALL.csv")

```

Create chunk selecting variables to create new dfs
```{r}

bbc_rootmass_TALL <- read.csv("bbc_rootmass_TALL.csv")
bbc_percore_TALL <- read.csv("bbc_percore_TALL.csv")

root.mass.TALL <- bbc_rootmass_TALL %>%
select(domainID, plotID, sampleID, subsampleID, collectDate, sizeCategory, rootStatus, dryMass)

root.core.TALL <- bbc_percore_TALL %>%
 select(domainID, plotID, subplotID, sampleID, clipID, coreID, collectDate, rootSampleArea, rootSampleDepth, coreDiameter)


root.data.TALL <- left_join(root.mass.TALL, root.core.TALL)

root.data.TALL$year <- substr(root.data.TALL$collectDate, start=1, stop=4) 

```

Root calculations and conversions
```{r}

roots.by.sample.TALL <- root.data.TALL %>% 
  group_by(plotID, sampleID, rootSampleArea, rootSampleDepth) %>%
  summarise(total.mass = sum(dryMass))

roots.by.sample.TALL.final <- roots.by.sample.TALL %>%
  mutate(root.gC.sample = (total.mass * 0.47)) %>%
  mutate(root.gC.m2 = (root.gC.sample/rootSampleArea)) %>%
  mutate(root.MgC.ha = (root.gC.m2 * 0.01))
 
roots.by.plot.TALL <- roots.by.sample.TALL.final %>% 
  group_by(plotID) %>%
  summarise(mean.root.MgC.ha = mean(root.MgC.ha))

```

Visualize the data
```{r}

ggplot(data=roots.by.plot.TALL, aes(x=plotID, y=mean.root.MgC.ha)) + 
geom_jitter()+
theme_classic()+
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

```

### Joining dataframes across D08 (Ozark Complex) for Tree Carbon Stocks
```{r}

roots.by.plot.D08 <- full_join(roots.by.plot.DELA, roots.by.plot.LENO)
roots.by.plot.D08 <- full_join(roots.by.plot.D08, roots.by.plot.TALL)

```

### Visualizing Root Carbon Stocks by site of D08
```{r}

roots.by.plot.D08$siteID <- str_sub(roots.by.plot.D08$plotID, 1, 4)

roots.by.plot.D08.summarise <- roots.by.plot.D08 %>%
 group_by(siteID) %>%
 summarise(mean.root.MgC.ha_siteAverage = mean(mean.root.MgC.ha),
           mean.root.MgC.ha_siteSD = sd(mean.root.MgC.ha)) 
 
ggplot(data=roots.by.plot.D08, aes(x=siteID, y=mean.root.MgC.ha, group = siteID, color=siteID)) + 
  geom_point(size=1.5, alpha = 0.3, position = position_jitterdodge(dodge.width = 0.5))  +
  geom_point(data = roots.by.plot.D08.summarise, aes(x = siteID, y = mean.root.MgC.ha_siteAverage, group = siteID, color=siteID), size = 3.5, alpha = 0.8, position = position_dodge(width = 0.5)) +
  geom_errorbar(data = roots.by.plot.D08.summarise, aes(x= siteID, y = mean.root.MgC.ha_siteAverage, ymin = (mean.root.MgC.ha_siteAverage-mean.root.MgC.ha_siteSD), ymax = (mean.root.MgC.ha_siteAverage+mean.root.MgC.ha_siteSD), colour = siteID), width = 0.2) +
        scale_color_brewer(name = "SiteID", palette = "Dark2") + #color-blind friendly
        ggtitle("Root Carbon Stocks by Site of D08") +
        ylab("Carbon Stock (Mg/ha)") +
        theme_classic(base_size = 16) +
        theme(plot.title = element_text(size=16, hjust = 0.5),
              axis.text.x=element_text(size=12, color = "black"),
              axis.text.y=element_text(size=12),
              axis.title.y=element_text(size=14), 
              axis.title.x=element_blank(), 
              legend.text=element_text(size=14),
              legend.title=element_text(size=14),
              legend.position = "none")

#Writing the joined dataframe into CSV file
write.csv(roots.by.plot.D08, "roots.by.plot.D08.csv")

```

## Soil

### DELA -- Soil Carbon Stocks

Downloading the data of interest from NEON, lising, and csvs
#COMMENTED OUT
```{r}												
# DELA.soil <- loadByProduct(dpID="DP1.10047.001",
# site=c("DELA"),
# startdate="2012-01", enddate="2024-12",
# package="basic")
# 
# list2env(DELA.soil, .GlobalEnv)
# 
# #spc_biogeochem
# write.csv(spc_biogeochem, "spc_biogeochem_DELA.csv")
# 
# #spc_bulkdensity
# write.csv(spc_bulkdensity, "spc_bulkdensity_DELA.csv")
```

To quantify soil carbon stocks, we need bulk density and % carbon values for each soil increment. Inconveniently, NEON does not put these variables into the same data set, so we need to perform some carpentry. All the steps below are similar to what you performed with trees and roots.

1a-3d
```{r}											
spc_biogeochem_DELA <- read.csv("spc_biogeochem_DELA.csv")
spc_bulkdensity_DELA <- read.csv("spc_bulkdensity_DELA.csv")

#making a new dataframe with selected variables
biogeochem.info.DELA <- spc_biogeochem_DELA %>%
select(domainID, siteID, plotID, collectDate, horizonID, horizonName, biogeoTopDepth, biogeoBottomDepth, carbonTot)

#making a new dataframe with selected variables
bulkdensity.info.DELA <- spc_bulkdensity_DELA %>%
select(domainID, siteID, plotID, collectDate, horizonID, horizonName, bulkDensThirdBar, bulkDensFieldMoist)

soil.data.DELA <- left_join(biogeochem.info.DELA, bulkdensity.info.DELA)

soil.data.DELA <- soil.data.DELA %>%
mutate(depth_increment = biogeoBottomDepth-biogeoTopDepth)

```

e)	GAP FILL View your data frame again. Notice how many NAs there are for the bulk density variable! This is a common problem—bulk density measures are rare. We will deal with this issue by ‘gap filling’.


```{r}
sum(is.na(soil.data.DELA$bulkDensThirdBar)) #18 observations for NA
sum(is.na(soil.data.DELA$bulkDensFieldMoist)) #82 observations for NA

#(2)	First calculate the mean bulk density (using bulkDensFieldMoist, since it’s more abundant) for each plot and then for each site. Perform the following steps:

## For DELA, lack of bulkDensFieldMoist data led me to use bulkDensThirdBar as the data which site and plot means are based on.

#(a) Use mutate to create a new variable in your existing dataframe of the mean bulk density of each plot. 
soil.data.DELA <- soil.data.DELA %>% 
 group_by(plotID) %>% 
 mutate(BD.plot.mean = mean(bulkDensThirdBar, na.rm=TRUE))

#(b)	Use mutate to calculate the mean bulk density of each site. Use similar steps as above, but group by siteID instead of plotID.
soil.data.DELA <- soil.data.DELA %>% 
 group_by(siteID) %>% 
 mutate(BD.site.mean = mean(bulkDensThirdBar, na.rm=TRUE))


#(3)	Gap fill using if_else to fill in values from bulkDensFieldMoist where bulkDensThirdBar is absent. Use this logic: if the NEON provided bulk density from third bar method is NA, apply the value from the FieldMoist method to the new variable ‘bulkdensity’, else, apply the ThirdBar value to the new variable ‘bulkdensity’.

soil.data.DELA <- soil.data.DELA %>% 
group_by(plotID) %>% 
mutate(bulkdensity = if_else(is.na(bulkDensThirdBar), bulkDensFieldMoist , bulkDensThirdBar))

sum(is.na(soil.data.DELA$bulkdensity)) #how many NAs? 18

#(4)	If you still have NAs use the following steps to backfill using this logic: if the NEON provided bulk density value is NA, apply the plot-level mean to the variable ‘bulkdensity’, else, apply the NEON provide value to the variable ‘bulkdensity’.

soil.data.DELA <- soil.data.DELA %>%
group_by(plotID) %>%
mutate(bulkdensity = if_else(is.na(bulkdensity), BD.plot.mean, bulkdensity))

sum(is.na(soil.data.DELA$bulkdensity)) #how many NAs? 15

#(5) Gap fill again with site-level mean. Use the if_else approach with this logic: if the new bulkdensity variable is NA, apply the site-level mean to the variable ‘bulkdensity,’ else apply the value already given to ‘bulkdensity’.

soil.data.DELA <- soil.data.DELA %>%
group_by(plotID) %>%
mutate(bulkdensity = if_else(is.na(bulkdensity), BD.site.mean, bulkdensity))

sum(is.na(soil.data.DELA$bulkdensity)) #how many NAs? 0

# View(soil.data.DELA)

```

f)	Calculate the soil carbon stock
```{r}
#(1)	Given bulk density and the depth increment of each horizon in your dataframe, create a new column in your dataframe that is the total amount of soil in grams for a m^2 area

#(a-d)	To do this, go back to your HSB code and notice how we calculated the sample volume for each depth increment. We used a m2 area, so use 100 cm x 100 cm  = 10,000 cm2 for the sample area in this case too.

soil.data.DELA <- soil.data.DELA %>% 
  mutate(sample.area.cm2 = 10000) %>%
  mutate(sample.volume = sample.area.cm2*depth_increment) %>%  #created an arbitrary variable of 10,000 cm2 that represents 1 m2 and then multiplying by the depth increment we calculated above to try to get volume, which will be now in cm3
  mutate(g_soil = sample.volume*bulkdensity) %>% #this is in g/m2
  mutate(kg_m2_soil = g_soil/1000) #should now be in kg/m2

#what are the units of carbonTots? According to variables_10047, units are gramsPerKilogram, g/kg

#(e-f) Calculate the total carbon by each depth increment... not using increment directly, but essentially using the kilograms per m2 of soil calculated above, since that represents the kilograms of soil at a given depth_increment within a m2 area.
soil.data.DELA <- soil.data.DELA %>% 
  mutate(carbon_stock_forDepth = carbonTot*kg_m2_soil) #units in g/m2
write.csv(soil.data.DELA, "soil.data.DELA.csv")

#(g-h) Create a new dataframe that sums the carbon stock of all the depth increments
soil.data.sum.DELA <- soil.data.DELA %>% 
  group_by(plotID, siteID) %>%
  summarise(total.carbon = sum(carbon_stock_forDepth))

#(h) Convert to Mg C per ha
soil.data.sum.DELA <- soil.data.sum.DELA %>% 
  mutate(soil.C.Mg.ha = (total.carbon*0.01))
  
  
#(i) Visualize the data
ggplot(data=soil.data.sum.DELA, aes(x=plotID, y=soil.C.Mg.ha)) + 
geom_jitter()+
theme_classic()+
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))


```


### LENO -- Soil Carbon Stocks

Downloading the data of interest from NEON, lising, and csvs
#COMMENTED OUT
```{r}												
# LENO.soil <- loadByProduct(dpID="DP1.10047.001",
# site=c("LENO"),
# startdate="2012-01", enddate="2024-12",
# package="basic")
# 
# list2env(LENO.soil, .GlobalEnv)
# 
# #spc_biogeochem
# write.csv(spc_biogeochem, "spc_biogeochem_LENO.csv")
# 
# #spc_bulkdensity
# write.csv(spc_bulkdensity, "spc_bulkdensity_LENO.csv")
```

To quantify soil carbon stocks, we need bulk density and % carbon values for each soil increment. Inconveniently, NEON does not put these variables into the same data set, so we need to perform some carpentry. All the steps below are similar to what you performed with trees and roots.

1a-3d
```{r}											
spc_biogeochem_LENO <- read.csv("spc_biogeochem_LENO.csv")
spc_bulkdensity_LENO <- read.csv("spc_bulkdensity_LENO.csv")

#making a new dataframe with selected variables
biogeochem.info.LENO <- spc_biogeochem_LENO %>%
select(domainID, siteID, plotID, collectDate, horizonID, horizonName, biogeoTopDepth, biogeoBottomDepth, carbonTot)

#making a new dataframe with selected variables
bulkdensity.info.LENO <- spc_bulkdensity_LENO %>%
select(domainID, siteID, plotID, collectDate, horizonID, horizonName, bulkDensThirdBar, bulkDensFieldMoist)

soil.data.LENO <- left_join(biogeochem.info.LENO, bulkdensity.info.LENO)

soil.data.LENO <- soil.data.LENO %>%
mutate(depth_increment = biogeoBottomDepth-biogeoTopDepth)

```

e)	GAP FILL View your data frame again. Notice how many NAs there are for the bulk density variable! This is a common problem—bulk density measures are rare. We will deal with this issue by ‘gap filling’.


```{r}
sum(is.na(soil.data.LENO$bulkDensThirdBar)) #0 observations for NA
sum(is.na(soil.data.LENO$bulkDensFieldMoist)) #65 observations for NA

#(2)	First calculate the mean bulk density (using BulkDensThirdBar, since it’s more abundant) for each plot and then for each site. Perform the following steps:

#Opted for bulkDensThirdBar for these, more abundant

#(a) Use mutate to create a new variable in your existing dataframe of the mean bulk density of each plot. 
soil.data.LENO <- soil.data.LENO %>% 
 group_by(plotID) %>% 
 mutate(BD.plot.mean = mean(bulkDensThirdBar, na.rm=TRUE))

#(b)	Use mutate to calculate the mean bulk density of each site. Use similar steps as above, but group by siteID instead of plotID.
soil.data.LENO <- soil.data.LENO %>% 
 group_by(siteID) %>% 
 mutate(BD.site.mean = mean(bulkDensThirdBar, na.rm=TRUE))


#(3)	Gap fill using if_else to fill in values from bulkDensFieldMoist where bulkDensThirdBar is absent. Use this logic: if the NEON provided bulk density from third bar method is NA, apply the value from the FieldMoist method to the new variable ‘bulkdensity’, else, apply the ThirdBar value to the new variable ‘bulkdensity’.

soil.data.LENO <- soil.data.LENO %>% 
group_by(plotID) %>% 
mutate(bulkdensity = if_else(is.na(bulkDensThirdBar), bulkDensFieldMoist , bulkDensThirdBar))

sum(is.na(soil.data.LENO$bulkdensity)) #how many NAs? 0

#Done with gap filling for LENO here, had to use bulkDensThirdBar.

#(4)	If you still have NAs use the following steps to backfill using this logic: if the NEON provided bulk density value is NA, apply the plot-level mean to the variable ‘bulkdensity’, else, apply the NEON provide value to the variable ‘bulkdensity’.

soil.data.LENO <- soil.data.LENO %>%
group_by(plotID) %>%
mutate(bulkdensity = if_else(is.na(bulkdensity), BD.plot.mean, bulkdensity))

sum(is.na(soil.data.LENO$bulkdensity)) #how many NAs? 11

#(5) Gap fill again with site-level mean. Use the if_else approach with this logic: if the new bulkdensity variable is NA, apply the site-level mean to the variable ‘bulkdensity,’ else apply the value already given to ‘bulkdensity’.

soil.data.LENO <- soil.data.LENO %>%
group_by(plotID) %>%
mutate(bulkdensity = if_else(is.na(bulkdensity), BD.site.mean, bulkdensity))

sum(is.na(soil.data.LENO$bulkdensity)) #how many NAs? 0

# View(soil.data.LENO)

```

f)	Calculate the soil carbon stock
```{r}
#(1)	Given bulk density and the depth increment of each horizon in your dataframe, create a new column in your dataframe that is the total amount of soil in grams for a m^2 area

#(a-d)	To do this, go back to your HSB code and notice how we calculated the sample volume for each depth increment. We used a m2 area, so use 100 cm x 100 cm  = 10,000 cm2 for the sample area in this case too.

soil.data.LENO <- soil.data.LENO %>% 
  mutate(sample.area.cm2 = 10000) %>%
  mutate(sample.volume = sample.area.cm2*depth_increment) %>%  #created an arbitrary variable of 10,000 cm2 that represents 1 m2 and then multiplying by the depth increment we calculated above to try to get volume, which will be now in cm3
  mutate(g_soil = sample.volume*bulkdensity) %>% #this is in g/m2
  mutate(kg_m2_soil = g_soil/1000) #should now be in kg/m2

#what are the units of carbonTots? According to variables_10047, units are gramsPerKilogram, g/kg

#(e-f) Calculate the total carbon by each depth increment... not using increment directly, but essentially using the kilograms per m2 of soil calculated above, since that represents the kilograms of soil at a given depth_increment within a m2 area.
soil.data.LENO <- soil.data.LENO %>% 
  mutate(carbon_stock_forDepth = carbonTot*kg_m2_soil) #units in g/m2

#(g-h) Create a new dataframe that sums the carbon stock of all the depth increments
soil.data.sum.LENO <- soil.data.LENO %>% 
  group_by(plotID, siteID) %>%
  summarise(total.carbon = sum(carbon_stock_forDepth))
write.csv(soil.data.LENO, "soil.data.LENO.csv")

#(h) Convert to Mg C per ha
soil.data.sum.LENO <- soil.data.sum.LENO %>% 
  mutate(soil.C.Mg.ha = (total.carbon*0.01))
  
  
#(i) Visualize the data
ggplot(data=soil.data.sum.LENO, aes(x=plotID, y=soil.C.Mg.ha)) + 
geom_jitter()+
theme_classic()+
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))


```

### TALL -- Soil Carbon Stocks

Downloading the data of interest from NEON, lising, and csvs
#COMMENTED OUT
```{r}												
# TALL.soil <- loadByProduct(dpID="DP1.10047.001",
# site=c("TALL"),
# startdate="2012-01", enddate="2024-12",
# package="basic")
# 
# list2env(TALL.soil, .GlobalEnv)
# 
# #spc_biogeochem
# write.csv(spc_biogeochem, "spc_biogeochem_TALL.csv")
# 
# #spc_bulkdensity
# write.csv(spc_bulkdensity, "spc_bulkdensity_TALL.csv")
```

To quantify soil carbon stocks, we need bulk density and % carbon values for each soil increment. Inconveniently, NEON does not put these variables into the same data set, so we need to perform some carpentry. All the steps below are similar to what you performed with trees and roots.

1a-3d
```{r}											
spc_biogeochem_TALL <- read.csv("spc_biogeochem_TALL.csv")
spc_bulkdensity_TALL <- read.csv("spc_bulkdensity_TALL.csv")

#making a new dataframe with selected variables
biogeochem.info.TALL <- spc_biogeochem_TALL %>%
select(domainID, siteID, plotID, collectDate, horizonID, horizonName, biogeoTopDepth, biogeoBottomDepth, carbonTot)

#making a new dataframe with selected variables
bulkdensity.info.TALL <- spc_bulkdensity_TALL %>%
select(domainID, siteID, plotID, collectDate, horizonID, horizonName, bulkDensThirdBar, bulkDensFieldMoist)

soil.data.TALL <- left_join(biogeochem.info.TALL, bulkdensity.info.TALL)

soil.data.TALL <- soil.data.TALL %>%
mutate(depth_increment = biogeoBottomDepth-biogeoTopDepth)

```

e)	GAP FILL View your data frame again. Notice how many NAs there are for the bulk density variable! This is a common problem—bulk density measures are rare. We will deal with this issue by ‘gap filling’.


```{r}
sum(is.na(soil.data.TALL$bulkDensThirdBar)) #94 observations for NA
sum(is.na(soil.data.TALL$bulkDensFieldMoist)) #19 observations for NA

#(2)	First calculate the mean bulk density (using bulkDensFieldMoist, since it’s more abundant) for each plot and then for each site. Perform the following steps:

#(a) Use mutate to create a new variable in your existing dataframe of the mean bulk density of each plot. 
soil.data.TALL <- soil.data.TALL %>% 
 group_by(plotID) %>% 
 mutate(BD.plot.mean = mean(bulkDensFieldMoist, na.rm=TRUE))

#(b)	Use mutate to calculate the mean bulk density of each site. Use similar steps as above, but group by siteID instead of plotID.
soil.data.TALL <- soil.data.TALL %>% 
 group_by(siteID) %>% 
 mutate(BD.site.mean = mean(bulkDensFieldMoist, na.rm=TRUE))


#(3)	Gap fill using if_else to fill in values from bulkDensFieldMoist where bulkDensThirdBar is absent. Use this logic: if the NEON provided bulk density from third bar method is NA, apply the value from the FieldMoist method to the new variable ‘bulkdensity’, else, apply the ThirdBar value to the new variable ‘bulkdensity’.

soil.data.TALL <- soil.data.TALL %>% 
group_by(plotID) %>% 
mutate(bulkdensity = if_else(is.na(bulkDensThirdBar), bulkDensFieldMoist , bulkDensThirdBar))

sum(is.na(soil.data.TALL$bulkdensity)) #how many NAs? 15

#(4)	If you still have NAs use the following steps to backfill using this logic: if the NEON provided bulk density value is NA, apply the plot-level mean to the variable ‘bulkdensity’, else, apply the NEON provide value to the variable ‘bulkdensity’.

soil.data.TALL <- soil.data.TALL %>%
group_by(plotID) %>%
mutate(bulkdensity = if_else(is.na(bulkdensity), BD.plot.mean, bulkdensity))

sum(is.na(soil.data.TALL$bulkdensity)) #how many NAs? 11

#(5) Gap fill again with site-level mean. Use the if_else approach with this logic: if the new bulkdensity variable is NA, apply the site-level mean to the variable ‘bulkdensity,’ else apply the value already given to ‘bulkdensity’.

soil.data.TALL <- soil.data.TALL %>%
group_by(plotID) %>%
mutate(bulkdensity = if_else(is.na(bulkdensity), BD.site.mean, bulkdensity))

sum(is.na(soil.data.TALL$bulkdensity)) #how many NAs? 0

# View(soil.data.TALL)

```

f)	Calculate the soil carbon stock
```{r}
#(1)	Given bulk density and the depth increment of each horizon in your dataframe, create a new column in your dataframe that is the total amount of soil in grams for a m^2 area

#(a-d)	To do this, go back to your HSB code and notice how we calculated the sample volume for each depth increment. We used a m2 area, so use 100 cm x 100 cm  = 10,000 cm2 for the sample area in this case too.

soil.data.TALL <- soil.data.TALL %>% 
  mutate(sample.area.cm2 = 10000) %>%
  mutate(sample.volume = sample.area.cm2*depth_increment) %>%  #created an arbitrary variable of 10,000 cm2 that represents 1 m2 and then multiplying by the depth increment we calculated above to try to get volume, which will be now in cm3
  mutate(g_soil = sample.volume*bulkdensity) %>% #this is in g/m2
  mutate(kg_m2_soil = g_soil/1000) #should now be in kg/m2

#what are the units of carbonTots? According to variables_10047, units are gramsPerKilogram, g/kg

#(e-f) Calculate the total carbon by each depth increment... not using increment directly, but essentially using the kilograms per m2 of soil calculated above, since that represents the kilograms of soil at a given depth_increment within a m2 area.
soil.data.TALL <- soil.data.TALL %>% 
  mutate(carbon_stock_forDepth = carbonTot*kg_m2_soil) #units in g/m2
write.csv(soil.data.TALL, "soil.data.TALL.csv")

#(g-h) Create a new dataframe that sums the carbon stock of all the depth increments
soil.data.sum.TALL <- soil.data.TALL %>% 
  group_by(plotID, siteID) %>%
  summarise(total.carbon = sum(carbon_stock_forDepth))

#(h) Convert to Mg C per ha
soil.data.sum.TALL <- soil.data.sum.TALL %>% 
  mutate(soil.C.Mg.ha = (total.carbon*0.01))
  
  
#(i) Visualize the data
ggplot(data=soil.data.sum.TALL, aes(x=plotID, y=soil.C.Mg.ha)) + 
geom_jitter()+
theme_classic()+
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))


```

### Joining dataframes across D08 (Ozark Complex) for Tree Carbon Stocks
```{r}

soil.by.plot.D08 <- full_join(soil.data.sum.DELA, soil.data.sum.LENO)
soil.by.plot.D08 <- full_join(soil.by.plot.D08, soil.data.sum.TALL)

```

### Visualizing Tree Carbon Stocks by site of D08
```{r}

soil.by.plot.D08.summarise <- soil.by.plot.D08 %>%
 group_by(siteID) %>%
 summarise(soil.C.Mg.ha_siteAverage = mean(soil.C.Mg.ha),
           soil.C.Mg.ha_siteSD = sd(soil.C.Mg.ha)) 
 
ggplot(data=soil.by.plot.D08, aes(x=siteID, y=soil.C.Mg.ha, group = siteID, color=siteID)) + 
  geom_point(size=1.5, alpha = 0.3, position = position_jitterdodge(dodge.width = 0.5))  +
  geom_point(data = soil.by.plot.D08.summarise, aes(x = siteID, y = soil.C.Mg.ha_siteAverage, group = siteID, color=siteID), size = 3.5, alpha = 0.8, position = position_dodge(width = 0.5)) +
  geom_errorbar(data = soil.by.plot.D08.summarise, aes(x= siteID, y = soil.C.Mg.ha_siteAverage, ymin = (soil.C.Mg.ha_siteAverage-soil.C.Mg.ha_siteSD), ymax = (soil.C.Mg.ha_siteAverage+soil.C.Mg.ha_siteSD), colour = siteID), width = 0.2) +
        scale_color_brewer(name = "SiteID", palette = "Dark2") + #color-blind friendly
        ggtitle("Soil Carbon Stocks by Site of D08") +
        ylab("Carbon Stock (Mg/ha)") +
        theme_classic(base_size = 16) +
        theme(plot.title = element_text(size=16, hjust = 0.5),
              axis.text.x=element_text(size=12, color = "black"),
              axis.text.y=element_text(size=12),
              axis.title.y=element_text(size=14), 
              axis.title.x=element_blank(), 
              legend.text=element_text(size=14),
              legend.title=element_text(size=14),
              legend.position = "none")


#Writing the joined dataframe into CSV file
write.csv(soil.by.plot.D08, "soil.by.plot.D08.csv")

```
# Nitrogen!!

## DELA
Downloading the data of interest from NEON, listing, and csvs
#COMMENTED OUT
```{r}												
#Loading
# DELA.soil.nitro <- loadByProduct(dpID="DP1.10086.001",
# site=c("DELA","LENO","TALL"),
# startdate="2012-01", enddate="2024-12",
# package="basic")
# 
#       list2env(DELA.soil.nitro, .GlobalEnv)
# 
#      # spc_biogeochem
#       write.csv(ntr_internalLab, "ntr_internalLab.csv")
# 
#      # spc_bulkdensity
#       write.csv(ntr_internalLabBlanks, "ntr_internalLabBlanks.csv")
#       
#             #spc_biogeochem
#       write.csv(ntr_externalLab, "ntr_externalLab.csv")
# 
#       #spc_bulkdensity
#       write.csv(sls_soilMoisture, "sls_soilMoisture.csv")

```

```{r}

ntr_internalLab <- read.csv("ntr_internalLab.csv")
ntr_internalLabBlanks <- read.csv("ntr_internalLabBlanks.csv")
ntr_externalLab <- read.csv("ntr_externalLab.csv")
sls_soilMoisture <-read.csv("sls_soilMoisture.csv")


      test.out <- def.calc.ntrans(kclInt = ntr_internalLab, kclIntBlank = ntr_internalLabBlanks, ntr_externalLab, soilMoist = sls_soilMoisture, dropConditions = c("extract stored at incorrect temperature", "soil stored at incorrect temperature", "mass uncertain", "volume uncertain"))

      
data.summary.D08 <- read.csv("datasummary.D08.csv")
str(data.summary.D08)


# Creating variable for siteID aand soil horizon s an independent variable in the dataframe by duplicating sample ID, subsetting the string, separating by the hyphen, and adding back to the original dataframe
data.summary.D08$siteID = substr(data.summary.D08$sampleID, 1,4)
data.summary.D08$siteID_tosplit = substr(data.summary.D08$sampleID, 1,10)
hold.name <- strsplit(data.summary.D08$siteID_tosplit, split="-")
hold.name.df <- as.data.frame(matrix(unlist(hold.name), ncol=2, byrow=T))
colnames(hold.name.df) <- c("plotID", "soilHorizon")
data.summary.D08$plotID <- hold.name.df$plotID
data.summary.D08$soilHorizon <- hold.name.df$soilHorizon

write.csv(data.summary.D08, "data.summary.D08_outputV2.csv")
```

Notably, the Inorganic nitrogen metric provided through the neonNTrans package includes nitrite, which we are not as interested in, but some micorbes being able to utilize it as an intermediate. We could not a clearly identifiable way to isolate nitrate from nitrite with the available data.


#Figures at the plot-level by site
```{r}
data.summary.D08.DELA <- data.summary.D08 %>%
  filter(siteID == "DELA")
data.summary.D08.LENO <- data.summary.D08 %>%
  filter(siteID == "LENO")
data.summary.D08.TALL <- data.summary.D08 %>%
  filter(siteID == "TALL")

exploratory.InorgN.DELA.plot <- ggplot(data=data.summary.D08.DELA, aes(x=plotID, y=soilInorganicNugPerGram)) + 
  geom_point(size=1.5, alpha = 1)  +
        #scale_color_brewer(name = "SiteID", palette = "Dark2") + #color-blind friendly
        ggtitle("Average Soil Inorganic N by Plot within DELA of D08") +
       #scale_y_continuous(breaks = seq(0, 100, 10), limits = c(-15, 100)) +
        ylab("Inorganic N (mcg/g)") +
     geom_jitter() +
    theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
exploratory.InorgN.DELA.plot

exploratory.InorgN.LENO.plot <- ggplot(data=data.summary.D08.LENO, aes(x=plotID, y=soilInorganicNugPerGram)) + 
  geom_point(size=1.5, alpha = 1)  +
        #scale_color_brewer(name = "SiteID", palette = "Dark2") + #color-blind friendly
        ggtitle("Average Soil Inorganic N by Plot within LENO of D08") +
       #scale_y_continuous(breaks = seq(0, 100, 10), limits = c(-15, 100)) +
        ylab("Inorganic N (mcg/g)") +
     geom_jitter() +
    theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
exploratory.InorgN.LENO.plot

exploratory.InorgN.TALLplot <- ggplot(data=data.summary.D08.TALL, aes(x=plotID, y=soilInorganicNugPerGram)) + 
  geom_point(size=1.5, alpha = 1)  +
        #scale_color_brewer(name = "SiteID", palette = "Dark2") + #color-blind friendly
        ggtitle("Average Soil Inorganic N by Plot within TALL of D08") +
       #scale_y_continuous(breaks = seq(0, 100, 10), limits = c(-15, 100)) +
        ylab("Inorganic N (mcg/g)") +
     geom_jitter() +
    theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
exploratory.InorgN.TALLplot


```

#Figures at the site-level
```{r}

# Initial visualization of data for Inorganic N
data.summary.D08.Exploratory <- data.summary.D08 %>%
 group_by(siteID) %>%
 summarise(soilInorganicNugPerGram_average = mean(soilInorganicNugPerGram),
           soilInorganicNugPerGram_sd = sd(soilInorganicNugPerGram))

exploratory.InorgN.D08 <- ggplot(data=data.summary.D08, aes(x=siteID, y=soilInorganicNugPerGram, group = siteID, color=siteID)) + 
  geom_point(size=1.5, alpha = 0.3, position = position_jitterdodge(dodge.width = 0.5))  +
  geom_point(data = data.summary.D08.Exploratory, aes(x = siteID, y = soilInorganicNugPerGram_average, group = siteID, color=siteID), size = 3.5, alpha = 0.8, position = position_dodge(width = 0.5)) +
  geom_errorbar(data = data.summary.D08.Exploratory, aes(x= siteID, y = soilInorganicNugPerGram_average, ymin = (soilInorganicNugPerGram_average-soilInorganicNugPerGram_sd), ymax = (soilInorganicNugPerGram_average+soilInorganicNugPerGram_sd), colour = siteID), width = 0.2) +
        scale_color_brewer(name = "SiteID", palette = "Dark2") + #color-blind friendly
        ggtitle("Average Soil Inorganic N (ug/gram) by Site of D08") +
       scale_y_continuous(breaks = seq(0, 100, 10), limits = c(-15, 100)) +
        ylab("Inorganic N (mcg/g)") +
        theme_classic(base_size = 16) +
        theme(plot.title = element_text(size=16, hjust = 0.5),
              axis.text.x=element_text(size=12, color = "black"),
              axis.text.y=element_text(size=12),
              axis.title.y=element_text(size=14), 
              axis.title.x=element_blank(), 
              legend.text=element_text(size=14),
              legend.title=element_text(size=14),
              legend.position = "none")

# Initial visualization of data for Ammonium
data.summary.D08.Exploratory.NH4 <- data.summary.D08 %>%
 group_by(siteID) %>%
 summarise(soilAmmoniumNugPerGram_average = mean(soilAmmoniumNugPerGram),
           soilAmmoniumNugPerGram_sd = sd(soilAmmoniumNugPerGram))

# exploratory.ammonium.D08 <- ggplot(data=data.summary.D08, aes(x=siteID, y=soilAmmoniumNugPerGram, group = siteID, color=siteID)) + 
#   geom_point(size=1.5, alpha = 0.3, position = position_jitterdodge(dodge.width = 0.5))  +
#   geom_point(data = data.summary.D08.Exploratory.NH4, aes(x = siteID, y = soilAmmoniumNugPerGram_average, group = siteID, color=siteID), size = 3.5, alpha = 0.8, position = position_dodge(width = 0.5)) +
#   geom_errorbar(data = data.summary.D08.Exploratory.NH4, aes(x= siteID, y = soilAmmoniumNugPerGram_average, ymin = (soilAmmoniumNugPerGram_average-soilAmmoniumNugPerGram_sd), ymax = (soilAmmoniumNugPerGram_average+soilAmmoniumNugPerGram_sd), colour = siteID), width = 0.2) +
#         scale_color_brewer(name = "SiteID", palette = "Dark2") + #color-blind friendly
#         ggtitle("Average Soil Ammonium (ug/gram) by Site of D08") +
#        scale_y_continuous(breaks = seq(-10, 80, 10), limits = c(-10, 65)) +
#       scale_y_break(c(32, 48)) +
#         ylab("Ammonium (mcg/g)") +
#         theme_classic(base_size = 16) +
#         theme(plot.title = element_text(size=16, hjust = 0.5),
#               axis.text.x=element_text(size=12, color = "black"),
#               axis.text.y=element_text(size=12),
#               axis.title.y=element_text(size=14), 
#               axis.title.x=element_blank(), 
#               axis.text.y.right = element_blank(), #deals with weird ggbreak glitch
#               axis.line.y.right = element_blank(), #deals with weird ggbreak glitch
#               axis.ticks.y.right = element_blank(), #deals with weird ggbreak glitch
#               legend.text=element_text(size=14),
#               legend.title=element_text(size=14),
#               legend.position = "none")
# 
# exploratory.InorgN.D08
# exploratory.ammonium.D08
# 
# # Initial visualization of data for Mineralization
# data.summary.D08.Exploratory.Mineralization <- data.summary.D08 %>%
#  group_by(siteID) %>%
#  summarise(netNminugPerGramPerDay_average = mean(netNminugPerGramPerDay), #averaging a rate, always messes with my head if appropriately statistically
#            netNminugPerGramPerDay_sd = sd(netNminugPerGramPerDay))
# 
# exploratory.mineralization.D08 <- ggplot(data=data.summary.D08, aes(x=siteID, y=netNminugPerGramPerDay, group = siteID, color=siteID)) + 
#   geom_point(size=1.5, alpha = 0.3, position = position_jitterdodge(dodge.width = 0.5))  +
#   geom_point(data = data.summary.D08.Exploratory.Mineralization, aes(x = siteID, y = netNminugPerGramPerDay_average, group = siteID, color=siteID), size = 3.5, alpha = 0.8, position = position_dodge(width = 0.5)) +
#   geom_errorbar(data = data.summary.D08.Exploratory.Mineralization, aes(x= siteID, y = netNminugPerGramPerDay_average, ymin = (netNminugPerGramPerDay_average-netNminugPerGramPerDay_sd), ymax = (netNminugPerGramPerDay_average+netNminugPerGramPerDay_sd), colour = siteID), width = 0.2) +
#         scale_color_brewer(name = "SiteID", palette = "Dark2") + #color-blind friendly
#         ggtitle("Average Soil N Mineralization rate ((ug/gram)/day) by Site of D08") +
#        #scale_y_continuous(breaks = seq(-10, 80, 10), limits = c(-10, 65)) +
#      # scale_y_break(c(32, 48)) +
#         ylab("Mineralization ((mcg/g)/day)") +
#         theme_classic(base_size = 16) +
#         theme(plot.title = element_text(size=16, hjust = 0.5),
#               axis.text.x=element_text(size=12, color = "black"),
#               axis.text.y=element_text(size=12),
#               axis.title.y=element_text(size=14), 
#               axis.title.x=element_blank(), 
#              #axis.text.y.right = element_blank(), #deals with weird ggbreak glitch
#               #axis.line.y.right = element_blank(), #deals with weird ggbreak glitch
#               #axis.ticks.y.right = element_blank(), #deals with weird ggbreak glitch
#               legend.text=element_text(size=14),
#               legend.title=element_text(size=14),
#               legend.position = "none")
# 
# exploratory.mineralization.D08 #note, getting a missing values warning
```

#Figures at the site-level
```{r}

D08.nitrogen.df <- read.csv("data.summary.D08_outputV2.csv")
str(D08.nitrogen.df) #443 observations

#When initially tried to join with carbon dataframe, was losing observations, likely because there are multiple observations by plot. Going to calculate by plot level for inorganic nitrogen and see if that was the issue...

D08.nitrogen.df.plot <- D08.nitrogen.df %>%
  group_by(plotID) %>%
  summarise(soilInorganicNugPerGram.average = mean(soilInorganicNugPerGram)) #note, this is on a per gram basis, not on the plot scale... could calculate that...


##playing around calculating on the plot scale precisely

#note this is contingent on having the other carbon data in environment
soil.data.DELA <- read.csv("soil.data.DELA.csv")
soil.data.LENO <- read.csv("soil.data.LENO.csv")
soil.data.TALL <- read.csv("soil.data.TALL.csv")
str(soil.data.DELA) #70
str(soil.data.LENO) #103
str(soil.data.TALL) #80

soil.data.D08.join1 <- full_join(soil.data.DELA, soil.data.LENO)
soil.data.D08.all <- full_join(soil.data.D08.join1, soil.data.TALL)
str(soil.data.D08.all) #looks like it adds up at 253
#Okay, I want to extract bulk density averaged at the plot level to join onto to nitrogen dataframe...

soil.data.D08.all.BDmeans.plots <- soil.data.D08.all %>%
  distinct(siteID, plotID, BD.plot.mean) %>%
  filter(!is.nan(BD.plot.mean))

soil.data.D08.all.BDmeans.sites <- soil.data.D08.all %>%
  distinct(siteID, BD.site.mean) %>%
  group_by(siteID) %>%
  summarise(BD.site.mean = mean(BD.site.mean)) #had to do some coercive coding since unsure why distinct insisted on still grouping by plotID althought no specified

#Now, to avoid excessive NAs, we are going to sequentially join to first add plot mean onto nitrogen dataframe, and then add on the site-level mean to ensure that doesn't have any NAs. From there, can then gap fill into a new bulk density variable to be able to calculate the total inorganic nitrogen that would be estimated at the plot level for each sample, to then use all those estimate to produce the 'average' estimate at the plot and site level for lm() with carbon, since they will now be on the same scale (I think)

D08.nitrogen.df.BDinfo <- left_join(D08.nitrogen.df, soil.data.D08.all.BDmeans.plots)
D08.nitrogen.df.BDinfo <- left_join(D08.nitrogen.df.BDinfo, soil.data.D08.all.BDmeans.sites) 

#Appears to have been successful, now let's gap fill to make that bulk density variable in the dataframe
#Telling R to see if the bulk density of the plot mean is available, and if it is not, then apply the value from the site mean variable, or else just keep the NA in the plot mean in this new variable
D08.nitrogen.df.BDinfo <- D08.nitrogen.df.BDinfo %>%
  mutate(bulkdensity = if_else(is.na(BD.plot.mean), BD.site.mean, BD.plot.mean))

sum(is.na(D08.nitrogen.df.BDinfo$bulkdensity)) #No NAs!


#(1)	Given bulk density and the depth increment of each horizon in your dataframe, create a new column in your dataframe that is the total amount of soil in grams for a m^2 area
#We used a m2 area, so use 100 cm x 100 cm  = 10,000 cm2 for the sample area in this case too.


D08.nitrogen.df.draft <- D08.nitrogen.df.BDinfo %>%
  mutate(sample.area.cm2 = 10000) %>%
  mutate(sample.volume = sample.area.cm2*30) %>% 
  mutate(g.soil = sample.volume*bulkdensity) %>% #should give units of g/m2  
  mutate(InorganicN.ugm2 = g.soil*soilInorganicNugPerGram) %>% # g/m2 * ug / g = ug/m2 
  mutate(InorganicN.ugHectare = InorganicN.ugm2 * (10000/1)) %>% # ug/m2 * m2/ha = ug/ha
  mutate(InorganicN.gHectare = InorganicN.ugHectare * (1/1000000)) %>% #ug/ha * g/ug= g/ha
  mutate(InorganicN.kgHectare = InorganicN.gHectare * (1/1000)) # g/ha * kg/g = kg/ha 
write.csv(D08.nitrogen.df.draft, "D08.nitrogen.df.draft.csv")

```

#Carpentry for summarizing N data by plot
```{r}
D08.nitrogen.df.draft<-D08.nitrogen.df.draft[!is.na(D08.nitrogen.df.draft$InorganicN.kgHectare),]

D08.nitrogen.byplot <- D08.nitrogen.df.draft %>%
  group_by(plotID) %>%
  summarise(InorganicN.kgHectare = mean(InorganicN.kgHectare), na.rm=TRUE)
```

```{r}
# Initial visualization of data for Inorganic N
# D08.nitrogen.df.draft.Exploratory <- D08.nitrogen.df.draft %>%
#  group_by(siteID, plotID) %>%
#  summarise(InorganicN.ugHectare_average.plot = mean(InorganicN.ugHectare),
#            InorganicN.ugHectare_sd.plot = sd(InorganicN.ugHectare))
# 
# exploratory.InorgN.D08 <- ggplot(data=D08.nitrogen.df.draft.Exploratory, aes(x=siteID, y=InorganicN.ugHectare_average.plot, group = siteID, color=siteID)) + 
#   geom_point(size=1.5, alpha = 0.3, position = position_jitterdodge(dodge.width = 0.5))  +
#         scale_color_brewer(name = "SiteID", palette = "Dark2") + #color-blind friendly
#         ggtitle("Average Soil Inorganic N per 1 Hectare by Site of D08") +
#        #scale_y_continuous(breaks = seq(0, 100, 10), limits = c(-15, 30)) +
#         ylab("Inorganic N (mcg/hectare)") +
#         theme_classic(base_size = 16) +
#         theme(plot.title = element_text(size=16, hjust = 0.5),
#               axis.text.x=element_text(size=12, color = "black"),
#               axis.text.y=element_text(size=12),
#               axis.title.y=element_text(size=14), 
#               axis.title.x=element_blank(), 
#               legend.text=element_text(size=14),
#               legend.title=element_text(size=14),
#               legend.position = "none")
# exploratory.InorgN.D08
```

# Final work with merged datasets (4-27-25)

## Modeling merged C+N
```{r}
D02.D03.D08.D19.fulljoin.CN.test <- read.csv("D02.D03.D08.D19.fulljoin.CN.test.csv")
```

### Aboveground
```{r}
AGBmodel <- lme(InorganicN.kgHectare ~ AGB.C.Mg.ha + domainID + AGB.C.Mg.ha*domainID, 
               random = ~1 | siteID/plotID,
               correlation = corAR1(),
               data = D02.D03.D08.D19.fulljoin.CN.test,
              na.action=na.exclude)
summary(AGBmodel)
```

### Results from Aboveground

#No C stock effect on Inorg N  

#No effect of domain only on Inorg N 

#One Significant interaction between domain + aboveground C on inorgN at D19 (Value=0.235566, SE=0.067212, DF= 49, t=3.504820, p = 0.0010). 

### Roots
```{r}
rootsmodel <- lme(InorganicN.kgHectare ~ mean.root.MgC.ha + domainID + mean.root.MgC.ha*domainID, 
               random = ~1 | siteID/plotID,
               correlation = corAR1(),
               data = D02.D03.D08.D19.fulljoin.CN.test,
              na.action=na.exclude)
summary(rootsmodel)
```

### Results from roots

#Root C stock of 1% causes Inorg N to decrease by 2.382435 kg/ha (SE = 	0.633862, DF = 29, t=	-3.758600, p = 0.0008). 

#Domain 3 has significantly lower InorgN to Root C than Domain 2 (value = -19.756165, SE=5.133434, DF=7, t = -3.848528, p = 0.0063). 

#I got lazy - all interactions signif. (p<0.05) 


### Soil
```{r}
soilmodel <- lme(InorganicN.kgHectare ~ soil.C.Mg.ha + domainID + soil.C.Mg.ha*domainID, 
               random = ~1 | siteID/plotID,
               correlation = corAR1(),
               data = D02.D03.D08.D19.fulljoin.CN.test,
              na.action=na.exclude)
summary(soilmodel)
```
### Results from soil
#No C stock effect on Inorg N  

#No effect of domain only on Inorg N 

#One Significant interaction between domain + soil C on inorgN at D03 (value = 0.241766, SE=0.082945, DF=35, t=2.9147926, p=0.0062). 

### Visualization

#New dataframes w/ predict
```{r}
AGBmodeldf <- D02.D03.D08.D19.fulljoin.CN.test %>%
  filter(!is.na(AGB.C.Mg.ha), !is.na(InorganicN.kgHectare))
soilmodeldf <- D02.D03.D08.D19.fulljoin.CN.test %>%
  filter(!is.na(soil.C.Mg.ha), !is.na(InorganicN.kgHectare))
rootsmodeldf <- D02.D03.D08.D19.fulljoin.CN.test %>%
  filter(!is.na(mean.root.MgC.ha), !is.na(InorganicN.kgHectare))
AGBmodeldf$pred <- predict(AGBmodel, newdata = AGBmodeldf, level=1)
soilmodeldf$pred <- predict(soilmodel, newdata = soilmodeldf, level=1)
rootsmodeldf$pred <- predict(rootsmodel, newdata = rootsmodeldf, level=1)
```

#Aboveground plot
```{r}
AGBplot <- ggplot(AGBmodeldf, aes(x = AGB.C.Mg.ha, y = InorganicN.kgHectare, color = siteID)) +
  geom_point(alpha = 0.6) +
       geom_line(data = AGBmodeldf, aes(x = AGB.C.Mg.ha, y = pred, group = siteID), linewidth = 1) +
  facet_wrap(~ domainID, nrow=2, scales = "free") +
  theme_minimal() +
  labs(
    x = "Aboveground carbon stock (Mg C/ha)",
    y = "Inorganic nitrogen (kg/ha)",
    color = "Site"
  ) +
  theme(strip.text = element_text(size = 12), 
        legend.position = "bottom")+
    theme_classic()

AGBplot
```

#Soil plot
```{r}
soilplot <- ggplot(soilmodeldf, aes(x = soil.C.Mg.ha, y = InorganicN.kgHectare, color = siteID)) +
  geom_point(alpha = 0.6) +
       geom_line(data = soilmodeldf, aes(x = soil.C.Mg.ha, y = pred, group = siteID), linewidth = 1) +
  facet_wrap(~ domainID, nrow=2, scales = "free") +
  theme_minimal() +
  labs(
    x = "Soil carbon stock (Mg C/ha)",
    y = "Inorganic nitrogen (kg/ha)",
    color = "Site"
  ) +
  theme(strip.text = element_text(size = 12), 
        legend.position = "bottom")+
    theme_classic()

soilplot
```

#Roots plot
```{r}
rootsplot <- ggplot(rootsmodeldf, aes(x = mean.root.MgC.ha, y = InorganicN.kgHectare, color = siteID)) +
  geom_point(alpha = 0.6) +
       geom_line(data = rootsmodeldf, aes(x = mean.root.MgC.ha, y = pred, group = siteID), linewidth = 1) +
  facet_wrap(~ domainID, nrow=2, scales = "free") +
  theme_minimal() +
  labs(
    x = "Root carbon stock (Mg C/ha)",
    y = "Inorganic nitrogen (kg/ha)",
    color = "Site"
  ) +
  theme(strip.text = element_text(size = 12), 
        legend.position = "bottom")+
    theme_classic()

rootsplot
```

